{"version":3,"sources":["webpack:///nodecg-replicant-built.js","webpack:///webpack/bootstrap 386e6b0e29048c75ea19","webpack:///./nodecg-replicant.js","webpack:///./~/clone/clone.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","clone","Polymer","is","properties","value","type","Object","observer","notify","hostAttributes","hidden","behaviors","NodeCGReplicantTargetingBehavior","_exposedValueChanged","newVal","this","_ignoreExposedValueObserver","replicant","_replicantChanged","oldVal","operations","clonedNewVal","fire","bubbles","parent","circular","depth","prototype","_clone","child","proto","__isArray","__isRegExp","RegExp","source","__getRegExpFlags","lastIndex","__isDate","Date","getTime","useBuffer","Buffer","isBuffer","length","copy","getPrototypeOf","create","index","allParents","indexOf","allChildren","push","i","attrs","getOwnPropertyDescriptor","set","filter","Infinity","__objToStr","o","toString","re","flags","global","ignoreCase","multiline","clonePrototype"],"mappings":"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","file":"nodecg-replicant-built.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* eslint-env node */\n\t/* eslint-disable accessor-pairs */\n\t'use strict';\n\t\n\tconst clone = __webpack_require__(1);\n\t\n\tPolymer({\n\t\tis: 'nodecg-replicant',\n\t\n\t\tproperties: {\n\t\t\tvalue: {\n\t\t\t\ttype: Object,\n\t\t\t\tobserver: '_exposedValueChanged',\n\t\t\t\tnotify: true\n\t\t\t}\n\t\t},\n\t\n\t\t/**\n\t\t * Fired when the value of the target replicant changes.\n\t\t * @event change\n\t\t */\n\t\n\t\thostAttributes: {\n\t\t\thidden: true\n\t\t},\n\t\n\t\tbehaviors: [\n\t\t\tPolymer.NodeCGReplicantTargetingBehavior\n\t\t],\n\t\n\t\t_exposedValueChanged: function (newVal) {\n\t\t\tif (!this._ignoreExposedValueObserver && this.replicant) {\n\t\t\t\tthis.replicant.value = newVal;\n\t\t\t\treturn this.replicant.value;\n\t\t\t}\n\t\t},\n\t\n\t\t_replicantChanged: function (newVal, oldVal, operations) {\n\t\t\tconst clonedNewVal = clone(newVal);\n\t\t\tthis._ignoreExposedValueObserver = true;\n\t\t\tthis.value = clonedNewVal;\n\t\t\tthis._ignoreExposedValueObserver = false;\n\t\t\tthis.fire('change', {\n\t\t\t\tnewVal: clonedNewVal,\n\t\t\t\toldVal: oldVal,\n\t\t\t\toperations: operations\n\t\t\t}, {bubbles: false});\n\t\t}\n\t});\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\tvar clone = (function() {\n\t'use strict';\n\t\n\t/**\n\t * Clones (copies) an Object using deep copying.\n\t *\n\t * This function supports circular references by default, but if you are certain\n\t * there are no circular references in your object, you can save some CPU time\n\t * by calling clone(obj, false).\n\t *\n\t * Caution: if `circular` is false and `parent` contains circular references,\n\t * your program may enter an infinite loop and crash.\n\t *\n\t * @param `parent` - the object to be cloned\n\t * @param `circular` - set to true if the object to be cloned may contain\n\t *    circular references. (optional - true by default)\n\t * @param `depth` - set to a number if the object is only to be cloned to\n\t *    a particular depth. (optional - defaults to Infinity)\n\t * @param `prototype` - sets the prototype to be used when cloning an object.\n\t *    (optional - defaults to parent prototype).\n\t*/\n\tfunction clone(parent, circular, depth, prototype) {\n\t  var filter;\n\t  if (typeof circular === 'object') {\n\t    depth = circular.depth;\n\t    prototype = circular.prototype;\n\t    filter = circular.filter;\n\t    circular = circular.circular\n\t  }\n\t  // maintain two arrays for circular references, where corresponding parents\n\t  // and children have the same index\n\t  var allParents = [];\n\t  var allChildren = [];\n\t\n\t  var useBuffer = typeof Buffer != 'undefined';\n\t\n\t  if (typeof circular == 'undefined')\n\t    circular = true;\n\t\n\t  if (typeof depth == 'undefined')\n\t    depth = Infinity;\n\t\n\t  // recurse this function so we don't reset allParents and allChildren\n\t  function _clone(parent, depth) {\n\t    // cloning null always returns null\n\t    if (parent === null)\n\t      return null;\n\t\n\t    if (depth == 0)\n\t      return parent;\n\t\n\t    var child;\n\t    var proto;\n\t    if (typeof parent != 'object') {\n\t      return parent;\n\t    }\n\t\n\t    if (clone.__isArray(parent)) {\n\t      child = [];\n\t    } else if (clone.__isRegExp(parent)) {\n\t      child = new RegExp(parent.source, __getRegExpFlags(parent));\n\t      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n\t    } else if (clone.__isDate(parent)) {\n\t      child = new Date(parent.getTime());\n\t    } else if (useBuffer && Buffer.isBuffer(parent)) {\n\t      child = new Buffer(parent.length);\n\t      parent.copy(child);\n\t      return child;\n\t    } else {\n\t      if (typeof prototype == 'undefined') {\n\t        proto = Object.getPrototypeOf(parent);\n\t        child = Object.create(proto);\n\t      }\n\t      else {\n\t        child = Object.create(prototype);\n\t        proto = prototype;\n\t      }\n\t    }\n\t\n\t    if (circular) {\n\t      var index = allParents.indexOf(parent);\n\t\n\t      if (index != -1) {\n\t        return allChildren[index];\n\t      }\n\t      allParents.push(parent);\n\t      allChildren.push(child);\n\t    }\n\t\n\t    for (var i in parent) {\n\t      var attrs;\n\t      if (proto) {\n\t        attrs = Object.getOwnPropertyDescriptor(proto, i);\n\t      }\n\t\n\t      if (attrs && attrs.set == null) {\n\t        continue;\n\t      }\n\t      child[i] = _clone(parent[i], depth - 1);\n\t    }\n\t\n\t    return child;\n\t  }\n\t\n\t  return _clone(parent, depth);\n\t}\n\t\n\t/**\n\t * Simple flat clone using prototype, accepts only objects, usefull for property\n\t * override on FLAT configuration object (no nested props).\n\t *\n\t * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n\t * works.\n\t */\n\tclone.clonePrototype = function clonePrototype(parent) {\n\t  if (parent === null)\n\t    return null;\n\t\n\t  var c = function () {};\n\t  c.prototype = parent;\n\t  return new c();\n\t};\n\t\n\t// private utility functions\n\t\n\tfunction __objToStr(o) {\n\t  return Object.prototype.toString.call(o);\n\t};\n\tclone.__objToStr = __objToStr;\n\t\n\tfunction __isDate(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n\t};\n\tclone.__isDate = __isDate;\n\t\n\tfunction __isArray(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n\t};\n\tclone.__isArray = __isArray;\n\t\n\tfunction __isRegExp(o) {\n\t  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n\t};\n\tclone.__isRegExp = __isRegExp;\n\t\n\tfunction __getRegExpFlags(re) {\n\t  var flags = '';\n\t  if (re.global) flags += 'g';\n\t  if (re.ignoreCase) flags += 'i';\n\t  if (re.multiline) flags += 'm';\n\t  return flags;\n\t};\n\tclone.__getRegExpFlags = __getRegExpFlags;\n\t\n\treturn clone;\n\t})();\n\t\n\tif (typeof module === 'object' && module.exports) {\n\t  module.exports = clone;\n\t}\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// nodecg-replicant-built.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 386e6b0e29048c75ea19","/* eslint-env node */\n/* eslint-disable accessor-pairs */\n'use strict';\n\nconst clone = require('clone');\n\nPolymer({\n\tis: 'nodecg-replicant',\n\n\tproperties: {\n\t\tvalue: {\n\t\t\ttype: Object,\n\t\t\tobserver: '_exposedValueChanged',\n\t\t\tnotify: true\n\t\t}\n\t},\n\n\t/**\n\t * Fired when the value of the target replicant changes.\n\t * @event change\n\t */\n\n\thostAttributes: {\n\t\thidden: true\n\t},\n\n\tbehaviors: [\n\t\tPolymer.NodeCGReplicantTargetingBehavior\n\t],\n\n\t_exposedValueChanged: function (newVal) {\n\t\tif (!this._ignoreExposedValueObserver && this.replicant) {\n\t\t\tthis.replicant.value = newVal;\n\t\t\treturn this.replicant.value;\n\t\t}\n\t},\n\n\t_replicantChanged: function (newVal, oldVal, operations) {\n\t\tconst clonedNewVal = clone(newVal);\n\t\tthis._ignoreExposedValueObserver = true;\n\t\tthis.value = clonedNewVal;\n\t\tthis._ignoreExposedValueObserver = false;\n\t\tthis.fire('change', {\n\t\t\tnewVal: clonedNewVal,\n\t\t\toldVal: oldVal,\n\t\t\toperations: operations\n\t\t}, {bubbles: false});\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./nodecg-replicant.js\n// module id = 0\n// module chunks = 0","var clone = (function() {\n'use strict';\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n*/\nfunction clone(parent, circular, depth, prototype) {\n  var filter;\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    filter = circular.filter;\n    circular = circular.circular\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth == 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n};\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n};\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n};\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n};\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n};\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/clone/clone.js\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}