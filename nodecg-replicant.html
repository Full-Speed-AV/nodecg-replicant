<link rel="import" href="../polymer/polymer.html">
<script src="../lodash/lodash.js"></script>
<script src="../object-path/index.js"></script>
<link rel="import" href="nodecg-replicant-targeting.html">

<!--
The `nodecg-replicant` element binds to a Replicant. Once bound, the value of the replicant can be retrieved and set
from the `value` property.

    <nodecg-replicant replicant-name="myReplicant" replicant-bundle="my-bundle"></nodecg-replicant>

This element is useful in cases where instantiating and binding to a replicant in a purely declarative fashion
is desirable. For example, it can be used to create a two-way binding with a `paper-input` element.

    <nodecg-replicant name="myReplicant" value="{{value}}"></nodecg-replicant>
    <paper-input label="myReplicant" value="{{value}}"></paper-input>

It is important to note that the replicant will not be declared until the element has been attached and the current
task has finished. This is to avoid two-way binding conflicts. For example, when binding to an `iron-input`
element, the `iron-input` will default to a `bind-value` of `""`, which will then be assigned to the Replicant.

@demo demo/index.html
@hero hero.svg
-->

<script>
    'use strict';

    Polymer({

        is: 'nodecg-replicant',

        /**
         * Fired when the value of the target replicant changes.
         *
         * @event change
         */

        hostAttributes: {
            hidden: true
        },

        behaviors: [
            Polymer.NodeCGReplicantTargetingBehavior
        ],

        get value () {
            if (this.replicant) {
                return this.replicant.value;
            }
        },

        set value (newVal) {
            if (this.replicant) {
                return this.replicant.value = newVal;
            }
        },

        /**
         * The current value of the target replicant.
         *
         * @return {*}
         */

        _replicantChanged: function(oldVal, newVal, changes) {
            this.fire('value-changed', {
                value: newVal
            }, {bubbles: false});

            if (changes) {
                changes.forEach(function (change) {
                    var pathParts = _.clone(change.path);
                    pathParts.unshift('value');
                    var path = pathParts.join('.');

                    switch (change.type) {
                        case 'add':
                        case 'update':
                        case 'delete':
                            this.notifyPath(path, change.newValue);
                            break;
                        case 'splice':
                            for (var i = 0; i < change.removedCount; i++) {
                                change.removed[i] = objectPath.get(this._oldValue, change.path)[change.index + i];
                            }

                            this.notifySplices(path, [change]);
                    }
                }.bind(this));
            }

            this._oldValue = _.clone(this.replicant.value);

            this.fire('change', {
                oldVal: oldVal,
                newVal: newVal,
                changes: changes
            }, {bubbles: false})
        }

    });
</script>
